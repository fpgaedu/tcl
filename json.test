# json.tcl tests
#
# Copyright (C) 2014, 2015, 2016 dbohdan.
#   Applies to original code from jimhttp library
#
# Copyright (C) 2017 Matthijs Bos <matthijs_vlaarbos@hotmail.com>
#   Applies to modifications
# 
# License: MIT
#
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation  and/or other materials provided with the distribution.
# 3. Neither the names of the copyright holders nor the names of any
#    contributors may be used to endorse or promote products derived from this
#    software without specific prior written permission.
# 
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#    POSSIBILITY OF SUCH DAMAGE.


package require tcltest

namespace import ::tcltest::*

source json.tcl

test testTokenizeString \
        "" \
        -body {
            ::fpgaedu::json::tokenize {"a"}
        } \
        -result [list [list STRING a]] 

cleanupTests

#test json \
#        -body {
#    source json.tcl
#
#    set d [dict create {*}{
#        array {0 Tokyo 1 Seoul 2 Shanghai}
#        object {Tokyo 37.8 Seoul 25.62 Shanghai 24.75}
#    }]
#
#    assert-equal [::json::tokenize {"a"}] [list [list STRING a]]
#    assert-equal [::json::tokenize {"ab\nc\"de"}] \
#            [list [list STRING ab\nc\"de]]
#
#    assert-equal [::json::tokenize {0}] [list [list NUMBER 0]]
#    assert-equal [::json::tokenize {0.}] [list [list NUMBER 0.]]
#    assert-equal [::json::tokenize {-0.1234567890}] \
#            [list [list NUMBER -0.1234567890]]
#    assert-equal [::json::tokenize {-525}] [list [list NUMBER -525]]
#    assert-equal [::json::tokenize {1E100}] [list [list NUMBER 1E100]]
#    assert-equal [::json::tokenize {1.23e-99}] [list [list NUMBER 1.23e-99]]
#    assert-equal [::json::tokenize {1.23e-99, 0, 0}] [list \
#            [list NUMBER 1.23e-99] COMMA \
#            [list NUMBER 0] COMMA \
#            [list NUMBER 0]]
#
#    assert-equal [::json::tokenize true] [list [list RAW true]]
#    assert-equal [::json::tokenize false] [list [list RAW false]]
#    assert-equal [::json::tokenize null] [list [list RAW null]]
#
#    assert-equal [::json::parse {[1.23e-99, 0, 0]} 0] \
#            [list 1.23e-99 0 0]
#    assert-equal [::json::parse {[ 1.23e-99,    0,     0 ]} 0] \
#            [list 1.23e-99 0 0]
#    assert-equal [::json::parse {[1.23e-99, "a", [1,2,3]]} 0] \
#            [list 1.23e-99 a {1 2 3}]
#    assert-equal [::json::parse {["alpha", "beta", "gamma"]} 0] \
#            [list alpha beta gamma]
#    assert-equal [::json::parse {["alpha", "beta", "gamma"]} 1] \
#            [list 0 alpha 1 beta 2 gamma]
#    assert-equal [::json::parse {[true,     false,null ]} 1] \
#            [list 0 true 1 false 2 null]
#    assert-equal [::json::parse {[]} 1] \
#            [list]
#
#
#    assert-equal [::json::parse {{"key": "value"}} 0] \
#            [list key value]
#    assert-equal \
#            [::json::parse {{    "key"   :        "value"    }} 0] \
#            [list key value]
#    assert-equal [::json::parse "\t{\t \"key\"\t:    \n\"value\"\n\r}" 0] \
#            [list key value]
#    assert-equal [::json::parse {{"key": [1, 2, 3]}} 0] \
#            [list key {1 2 3}]
#    assert-equal \
#            [::json::parse {{"k1": true, "k2": false, "k3": null}} 0] \
#            [list k1 true k2 false k3 null]
#    assert-equal [::json::parse {{}}] [list]
#    assert-equal [::json::parse {[]         }] [list]
#
#    assert-equal [::json::parse [::json::stringify $d 1] 1] $d
#
#    assert-equal [::json::stringify 0] 0
#    assert-equal [::json::stringify 0.5] 0.5
#    assert-equal [::json::stringify Hello] {"Hello"}
#    assert-equal [::json::stringify {key value}] {{"key": "value"}}
#    assert-equal \
#            [::json::stringify {0 a 1 b 2 c} 0] \
#            {{"0": "a", "1": "b", "2": "c"}}
#    assert-equal \
#            [::json::stringify {0 a 1 b 2 c} 1] \
#            {["a", "b", "c"]}
#
#    # Invalid JSON.
#    assert [catch {::json::parse x}]
#    # Trailing garbage.
#    assert [catch {::json::parse {"Hello" blah}}]
#
#    assert-equal [::json::subset {a b c} {a b c d e f}] 1
#    assert-equal [::json::subset {a b c d e f} {a b c}] 0
#    assert-equal [::json::subset {a b c d e f} {}] 0
#    assert-equal [::json::subset {} {a b c}] 1
#    assert-equal [::json::subset a a] 1
#
#    # Schema tests.
#
#    assert-equal [::json::stringify 0 1 number] 0
#    assert-equal [::json::stringify 0 1 string] \"0\"
#    assert-equal [::json::stringify 0 1 boolean] false
#    assert-equal [::json::stringify false 1 boolean] false
#    assert-equal [::json::stringify 1 1 boolean] true
#    assert-equal [::json::stringify true 1 boolean] true
#    assert-equal [::json::stringify null 1 null] null
#
#    assert [catch {::json::stringify 0 1 object}]
#    assert [catch {::json::stringify 0 1 noise}]
#    assert [catch {::json::stringify 0 1 array}]
#    assert [catch {::json::stringify x 1 boolean}]
#    assert [catch {::json::stringify x 1 null}]
#
#    assert-equal \
#            [::json::stringify \
#                    {key1 true key2 0.5 key3 1} 1 \
#                    {key1 boolean key2 number key3 number}] \
#            {{"key1": true, "key2": 0.5, "key3": 1}}
#    assert-equal \
#            [::json::stringify \
#                    {key1 true key2 0.5 key3 1} 1 \
#                    {key1 string key2 string key3 string}] \
#            {{"key1": "true", "key2": "0.5", "key3": "1"}}
#    assert-equal \
#            [::json::stringify {key1 {0 a 1 b}} 1 ""] \
#            [::json::stringify {key1 {0 a 1 b}} 1 {key1 ""}] \
#            [::json::stringify {key1 {0 a 1 b}} 1 {key1 {0 string 1 string}}] \
#            {{"key1": ["a", "b"]}}
#    assert [catch {
#        ::json::stringify {key1 {0 a 1 b}} 1 {key1 {0 string 2 string}} 1
#    }]
#    assert [catch {
#        ::json::stringify {key1 {0 a 1 b}} 1 {key1 {0 boolean}}
#    }]
#
#    assert-equal [::json::stringify {} 1 ""] {""}
#    assert-equal [::json::stringify {} 1 string] {""}
#    assert-equal [::json::stringify {key {}} 1 ""] {{"key": ""}}
#    assert-equal [::json::stringify {0 {} 1 {}} 1 ""] {["", ""]}
#    assert-equal [::json::stringify {} 1 array] {[]}
#    assert-equal [::json::stringify {} 1 object] "{}"
#    assert-equal \
#            [::json::stringify \
#                    {0 1 1 {0 1} 2 {0 x 1 null}} 1 \
#                    {0 boolean 1 {0 boolean} 2 array}] \
#            {[true, [true], ["x", null]]}
#    assert-equal \
#            [::json::stringify \
#                    {key1 1 key2 {0 1} key3 {0 x 1 null}} 1 \
#                    {0 boolean 1 {0 boolean} 2 array}] \
#            {{"key1": 1, "key2": [1], "key3": ["x", null]}}
#
#    assert-equal \
#            [::json::stringify {1 {key 1} 2 {x null} 3} 0 array] \
#            {[1, {"key": 1}, 2, {"x": null}, 3]}
#    assert-equal \
#            [::json::stringify {1 {key 1} 2 {x null} 3} 0 string] \
#            {"1 {key 1} 2 {x null} 3"}
#    assert-equal \
#            [::json::stringify {1 {key 1} 2 {x null} 3} 0 \
#                    {string string string string string}] \
#            {["1", "key 1", "2", "x null", "3"]}
#    assert-equal \
#            [::json::stringify {0 {key 1} 1 {x null}} 1 {N* string}] \
#            {["key 1", "x null"]}
#    assert-equal \
#            [::json::stringify {1 {key 1} 2 {x null}} 1 {* string}] \
#            {{"1": "key 1", "2": "x null"}}
#    assert-equal \
#            [::json::stringify {key {true false null}} 0 \
#                    {key {string string string}}]\
#            {{"key": ["true", "false", "null"]}}
#    assert-equal \
#            [::json::stringify {0 {n 1 s 1}} 0 {0 {n number s string}}] \
#            {{"0": {"n": 1, "s": "1"}}}
#
#    assert-equal \
#            [::json::stringify2 {1 {key 1} 2 {x null} 3} \
#                    -numberDictArrays 0 \
#                    -schema array \
#                    -compact 1] \
#            {[1,{"key":1},2,{"x":null},3]}
#    assert-equal \
#            [::json::stringify2 {1 {key 1} 2 {x null} 3} \
#                    -numberDictArrays 0 \
#                    -schema {string string string string string} \
#                    -compact 1] \
#            {["1","key 1","2","x null","3"]}
#    assert-equal \
#            [::json::stringify2 {1 {key 1} 2 {x null} 3 null} \
#                    -numberDictArrays 0 \
#                    -schema {string string string string string string} \
#                    -compact 1] \
#            {["1","key 1","2","x null","3","null"]}
#    assert-equal \
#            [::json::stringify2 {1 {key 1} 2 {x null}} \
#                    -numberDictArrays 0 \
#                    -schema {1 string 2 string} \
#                    -compact 1] \
#            {{"1":"key 1","2":"x null"}}
#    assert-equal \
#            [::json::stringify2 {0 {key 1} 1 {x null}} \
#                    -numberDictArrays 1 \
#                    -schema {N* string} \
#                    -compact 1] \
#            {["key 1","x null"]}
#    assert-equal \
#            [::json::stringify2 {1 {key 1} 2 {x null}} \
#                    -numberDictArrays 0 \
#                    -schema {1 string 2 string} \
#                    -compact 1] \
#            {{"1":"key 1","2":"x null"}}
#    assert-equal \
#            [::json::stringify2 {1 {key 1} 2 {x null}} \
#                    -numberDictArrays 0 \
#                    -schema {* string} \
#                    -compact 1] \
#            {{"1":"key 1","2":"x null"}}
#    assert-equal \
#            [::json::stringify2 {key {true false null}} \
#                    -numberDictArrays 0 \
#                    -schema {key {string string string}} \
#                    -compact 1] \
#            {{"key":["true","false","null"]}}
#    assert-equal \
#            [::json::stringify2 {a 0 b 1 c 2} \
#                    -numberDictArrays 1 \
#                    -schema {* string c number} \
#                    -compact 1] \
#            {{"a":"0","b":"1","c":2}}
#    assert-equal \
#            [::json::stringify2 {a 123 b {456 789}} \
#                    -numberDictArrays 0 \
#                    -schema {a string b {N* number}} \
#                    -strictSchema 1] \
#            {{"a": "123", "b": [456, 789]}}
#    assert-equal \
#            [::json::stringify2 {a b c d} \
#                    -numberDictArrays 0 \
#                    -schema {N* {}} \
#                    -strictSchema 1] \
#            {["a", "b", "c", "d"]}
#    assert [catch {::json::stringify2 {a 0 b 1} \
#            -numberDictArrays 0 \
#            -schema {a string} \
#            -strictSchema 1]}]
#    assert-equal \
#            [::json::stringify2 {a 0 b 1} \
#                    -numberDictArrays 0 \
#                    -schema {a string * string } \
#                    -strictSchema 1] \
#            {{"a": "0", "b": "1"}}
#    assert [catch {::json::stringify2 {a 0 b 1} -foo bar]}]
#}
#
